% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{pycontoltools Documentation}
\date{May 09, 2014}
\release{0.1}
\author{Chris Penndorf}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Contents:}
\label{index:documentation-of-the-python-module-pycontroltools}\label{index:contents}

\section{Documentation for the code}
\label{pycontroltools::doc}\label{pycontroltools:documentation-for-the-code}

\subsection{\textbf{lietools}}
\label{pycontroltools:lietools}

\subsubsection{\textbf{lie}}
\label{pycontroltools:lie}
The module \textbf{lie} contains functions concerning
different types of Lie-derivatives.
\phantomsection\label{pycontroltools:module-lietools.lietools}\index{lietools.lietools (module)}\phantomsection\label{pycontroltools:module-lie}\index{lie (module)}\index{jac() (in module lietools.lietools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:lietools.lietools.jac}\pysiglinewithargsret{\code{lietools.lietools.}\bfcode{jac}}{\emph{expr}, \emph{*args}}{}
Calculates the Jacobian matrix (derivative of a vectorial function)
using the \code{jacobian()} function from the module
\code{sympy.matrices.matrices.MatrixBase}.

\textbf{Advantage:} direct derivation of functions

Jacobian matrix:
\begin{quote}
\begin{gather}
\begin{split}J_f(a) :=  \left(\begin{matrix} 
            \frac{\partial f_1}{\partial x_1}(a) &
            \frac{\partial f_1}{\partial x_2}(a) &
            \ldots &
            \frac{\partial f_1}{\partial x_n}(a)\\
            \vdots & \vdots & \ddots & \vdots \\
            \frac{\partial f_m}{\partial x_1}(a) &
            \frac{\partial f_m}{\partial x_2}(a) & \ldots &
            \frac{\partial f_m}{\partial x_n}(a)
            \end{matrix}\right)\end{split}\notag
\end{gather}\end{quote}

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{expr}] \leavevmode{[}expression to derive{]}
function / row matrix/ column matrix

\end{description}

\item {} \begin{description}
\item[{args}] \leavevmode{[}coordinates{]}
separate or as list-like object

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : Jacobi matrix

\item {} 
type : sympy.Matrix

\end{itemize}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sympy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x1 x2 x3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{jac}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x2}\PYG{o}{+}\PYG{n}{x3}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{)}
\PYG{g+go}{Matrix([[2*x1, 2, 1]])}
\end{Verbatim}


\strong{See also:}


\code{sympy.jacobian()}



\end{fulllineitems}

\index{lie\_deriv() (in module lietools.lietools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:lietools.lietools.lie_deriv}\pysiglinewithargsret{\code{lietools.lietools.}\bfcode{lie\_deriv}}{\emph{sf}, \emph{vf}, \emph{x}, \emph{n=1}}{}
Calculates the Lie derivative of a scalar field $\lambda(x)$ along
a vector field $f(x)$ (e.g. {\hyperref[pycontroltools_sources:isidori]{{[}Isidori{]}}}):
\begin{quote}
\begin{gather}
\begin{split}L_f\lambda(x)   = \frac{ \partial{\lambda(x)} }{ \partial{x} }f(x)
                = grad^{T}\lambda(x)\cdot f(x)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

with $L_f^n\lambda(x)=\frac{ \partial{L_f^{n-1}\lambda(x)} }
{ \partial{x} }f(x)$ and $L_f^{0}\lambda(x) := \lambda(x)$

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{sf}] \leavevmode{[}scalar field to be derived{]}
function

\end{description}

\item {} \begin{description}
\item[{vf}] \leavevmode{[}vector field to derive along{]}
vector

\end{description}

\item {} \begin{description}
\item[{x}] \leavevmode{[}coordinates for derivation{]}
list

\end{description}

\item {} \begin{description}
\item[{n}] \leavevmode{[}number of derivations{]}
non-negative integer

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : scalar field

\item {} 
type : function

\end{itemize}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sympy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x1 x2 x3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x2} \PYG{o}{+} \PYG{n}{x3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x1}\PYG{o}{*}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lie\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{2*x1**2*x2 + x2 + 2*x3}
\end{Verbatim}


\strong{See also:}


\code{lie\_bracket()}, \code{lie\_deriv\_covf()}



\end{fulllineitems}

\index{lie\_bracket() (in module lietools.lietools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:lietools.lietools.lie_bracket}\pysiglinewithargsret{\code{lietools.lietools.}\bfcode{lie\_bracket}}{\emph{f}, \emph{g}, \emph{*args}, \emph{**kwargs}}{}
Calculates the Lie bracket for the vector field $g(x)$
along the vector field $f(x)$ (e.g. {\hyperref[pycontroltools_sources:isidori]{{[}Isidori{]}}}):
\begin{quote}
\begin{gather}
\begin{split}[f,g] = \frac{ \partial{g(x)} }{ \partial{x} }f(x)
        - \frac{ \partial{f(x)} }{ \partial{x} }g(x)
      = ad_fg(x)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

with $\quad$$ad_f^ng(x) = [f, ad_f^{n-1}g](x)$ $\quad$
and $\quad$ $ad_f^0g(x) := g(x)$

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{f}] \leavevmode{[}vector field (direction for derivation){]}
vector / list

\end{description}

\item {} \begin{description}
\item[{g}] \leavevmode{[}vector field to be derived{]}
vector / list

\end{description}

\item {} \begin{description}
\item[{args}] \leavevmode{[}coordinates{]}
separate or as list-like object

\end{description}

\end{itemize}

\textbf{Keyword Arguments}
\begin{itemize}
\item {} \begin{description}
\item[{n}] \leavevmode{[}number of derivations{]}
non-negative integer (default = 1)

\end{description}

\end{itemize}

\textbf{Exceptions}
\begin{itemize}
\item {} 
AssertionError : non-matching shapes of f, g, args

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : vector field

\item {} 
type : sympy.Matrix

\end{itemize}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sympy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x1 x2 x3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{g} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x1}\PYG{o}{*}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lie\PYGZus{}bracket}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{Matrix([}
\PYG{g+go}{[x1**3 + 2*x2**2 \PYGZhy{} 2*x3],}
\PYG{g+go}{[    \PYGZhy{}2*x1**2*x2 + 2*x3],}
\PYG{g+go}{[          x1**2 \PYGZhy{} 2*x2]])}
\end{Verbatim}


\strong{See also:}


\code{lie\_deriv()}, \code{lie\_deriv\_covf()}



\end{fulllineitems}

\index{lie\_deriv\_covf() (in module lietools.lietools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:lietools.lietools.lie_deriv_covf}\pysiglinewithargsret{\code{lietools.lietools.}\bfcode{lie\_deriv\_covf}}{\emph{w}, \emph{f}, \emph{*args}, \emph{**kwargs}}{}
Calculates the Lie derivative of the covector field $\omega(x)$
along the vector field $f(x)$ (e.g. {\hyperref[pycontroltools_sources:isidori]{{[}Isidori{]}}}):
\begin{quote}
\begin{gather}
\begin{split}L_f\omega(x) = f^T(x) \left( \frac{ \partial{\omega^T(x)} }
        { \partial{x} } \right)^{T} + \omega(x)
        \frac{ \partial{f(x)} }
        { \partial{x} }\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

with
\begin{quote}
\begin{gather}
\begin{split}L_f^n\omega(x) = f^T(x) \left( \frac{ \partial{(L_f^{n-1}\omega)^T(x)} }
        { \partial{x} } \right)^{T} + (L_f^{n-1}\omega)(x)
        \frac{ \partial{f(x)} }
        { \partial{x} }\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

and $\quad$ $L_f^0\omega(x) := \omega(x)$

Includes the option to omit the transposition of $\quad$
$\frac{ \partial{\omega^T(x)} }{ \partial{x} }$ $\quad$
with \code{transpose\_jac = False}:
\begin{quote}
\begin{gather}
\begin{split}L_f\omega(x) = f^T(x) \left( \frac{ \partial{\omega^T(x)} }
        { \partial{x} } \right) + \omega(x)\frac{ \partial{f(x)} }
        { \partial{x} }\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{w}] \leavevmode{[}covector field to be derived{]}
vector (sympy.Matrix of shape (1,m))

\end{description}

\item {} \begin{description}
\item[{f}] \leavevmode{[}vector field (direction of derivation){]}
vector (sympy.Matrix of shape (m,1))

\end{description}

\item {} \begin{description}
\item[{args}] \leavevmode{[}coordinates{]}
separate or as list-like object

\end{description}

\end{itemize}

\textbf{Keyword Arguments}
\begin{itemize}
\item {} \begin{description}
\item[{n}] \leavevmode{[}number of derivations{]}
non-negative integer (default = 1)

\end{description}

\item {} \begin{description}
\item[{transpose\_jac}] \leavevmode{[}transposition of $\frac{ \partial{\omega^T(x)} }{ \partial{x} }${]}
boolean (default = True)(Background: needed for some special applications)

\end{description}

\end{itemize}

\textbf{Exceptions}
\begin{itemize}
\item {} 
AssertionError : non-matching shapes of w, f, args

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : covector field

\item {} 
type : sympy.Matrix

\end{itemize}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sympy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x1 x2 x3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{w} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lie\PYGZus{}deriv\PYGZus{}covf}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{Matrix([[4*x2, 3*x1**2, 4*x3]])}
\end{Verbatim}


\strong{See also:}


\code{lie\_deriv()}, \code{lie\_bracket()}



\end{fulllineitems}



\subsection{\textbf{linearcontrol}}
\label{pycontroltools:linearcontrol}

\subsubsection{\textbf{linearcontrol}}
\label{pycontroltools:id4}
The module \textbf{linearcontrol} contains functions concerning
linear control algorithms.
\phantomsection\label{pycontroltools:module-linearcontrol.linearcontrol}\index{linearcontrol.linearcontrol (module)}\phantomsection\label{pycontroltools:module-linearcontrol}\index{linearcontrol (module)}\index{cont\_mat() (in module linearcontrol.linearcontrol)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.linearcontrol.cont_mat}\pysiglinewithargsret{\code{linearcontrol.linearcontrol.}\bfcode{cont\_mat}}{\emph{A}, \emph{B}}{}
Kallmanns controlability matrix

\end{fulllineitems}

\index{is\_left\_coprime() (in module linearcontrol.linearcontrol)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.linearcontrol.is_left_coprime}\pysiglinewithargsret{\code{linearcontrol.linearcontrol.}\bfcode{is\_left\_coprime}}{\emph{Ap}, \emph{Bp=None}, \emph{eps=1e-10}}{}
Test ob Ap,Bp Linksteilerfrei sind
keine Parameter zulässig

\end{fulllineitems}

\index{linear\_input\_trafo() (in module linearcontrol.linearcontrol)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.linearcontrol.linear_input_trafo}\pysiglinewithargsret{\code{linearcontrol.linearcontrol.}\bfcode{linear\_input\_trafo}}{\emph{B}, \emph{row\_idcs}}{}
serves to decouple inputs from each other

\end{fulllineitems}



\subsubsection{\textbf{robust\_poleplacement}}
\label{pycontroltools:robust-poleplacement}
The module \textbf{robust\_poleplacement} contains functions to calculate a robust
control matrix for multiple input systems.
\phantomsection\label{pycontroltools:module-linearcontrol.robust_poleplacement}\index{linearcontrol.robust\_poleplacement (module)}\phantomsection\label{pycontroltools:module-opt_polplatzierung}\index{opt\_polplatzierung (module)}\index{exchange\_all\_cols() (in module linearcontrol.robust\_poleplacement)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.robust_poleplacement.exchange_all_cols}\pysiglinewithargsret{\code{linearcontrol.robust\_poleplacement.}\bfcode{exchange\_all\_cols}}{\emph{V}, \emph{P\_list}}{}
For every column in V:
Calculates the 1-dimensional basis of the annihilator ($:= a_j$)
of all the other columns in V and projects $a_j$ to its
correspondent space out of P\_list.

Then in V: replaces $v_j$ with the new normalized
projected vector $v_{j,projected}$.


\strong{See also:}


\code{opt\_place\_MI()}



\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{V}] \leavevmode{[}matrix of eigenvectors $V = (v_1,..., v_n)${]}
sympy.Matrix

\end{description}

\item {} \begin{description}
\item[{P\_list}] \leavevmode{[}list of spaces $(S_{\mathrm{h}})_i$ for $i \in (1,...,n)${]}
list

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : new eigenvector matrix V

\item {} 
type : sympy.Matrix

\end{itemize}

\end{fulllineitems}

\index{full\_qr() (in module linearcontrol.robust\_poleplacement)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.robust_poleplacement.full_qr}\pysiglinewithargsret{\code{linearcontrol.robust\_poleplacement.}\bfcode{full\_qr}}{\emph{A}, \emph{only\_null\_space=False}}{}
Performs the QR numpy decomposition and augments the reduced
orthonormal matrix $Q_{red}$ by its transposed null space
$\mathrm{null}(Q_{red})^T$
(such that $Q$ is quadratic and regular).
\begin{quote}
\begin{gather}
\begin{split}Q = \left(\begin{matrix} 
        Q_{red} &
        \mathrm{null}(Q_{red})^T
    \end{matrix}\right)\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{A}] \leavevmode{[}matrix to be QR decomposed{]}
sympy.Matrix

\end{description}

\end{itemize}

\textbf{Keyword Arguments}
\begin{itemize}
\item {} \begin{description}
\item[{only\_null\_space}] \leavevmode{[}only the null space of $Q_{red}$ will be returned{]}
boolean (default = False)

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : Q (quadratic \& regular)

\item {} 
type : sympy.Matrix

\item {} 
returns : r (upper triangular matrix)

\item {} 
type : sympy.Matrix

\end{itemize}

\end{fulllineitems}

\index{opt\_place\_MI() (in module linearcontrol.robust\_poleplacement)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.robust_poleplacement.opt_place_MI}\pysiglinewithargsret{\code{linearcontrol.robust\_poleplacement.}\bfcode{opt\_place\_MI}}{\emph{A}, \emph{B}, \emph{*eigenvals}, \emph{**kwargs}}{}
Calculates and returns the optimal control matrix $B_K$ for the new
system matrix $(A + BB_K)$ of the closed loop system by the
algorithm described in {\hyperref[pycontroltools_sources:reinschke14]{{[}Reinschke14{]}}}.

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{A}] \leavevmode{[}state matrix of the open loop{]}
sympy.Matrix

\end{description}

\item {} \begin{description}
\item[{B}] \leavevmode{[}input matrix{]}
sympy.Matrix

\end{description}

\item {} \begin{description}
\item[{eigenvals}] \leavevmode{[}desired eigenvalues for the closed loop system{]}
separate or as list-like object

\end{description}

\end{itemize}

\textbf{Keyword Arguments}
\begin{itemize}
\item {} \begin{description}
\item[{rtol}] \leavevmode{[}relative tolerance of the change in the last iteration step of the{]}
resulting determinant of the eigenvector matrix

real number (default = 0.01)

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns :  $B_K$

\item {} 
type : sympy.Matrix

\end{itemize}

\end{fulllineitems}

\index{ortho\_complement() (in module linearcontrol.robust\_poleplacement)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:linearcontrol.robust_poleplacement.ortho_complement}\pysiglinewithargsret{\code{linearcontrol.robust\_poleplacement.}\bfcode{ortho\_complement}}{\emph{M}}{}
Gets a n,n-matrix M which is assumed to have rank n-1 and 
returns a ``column'' v with $v^T M = 0$ and $v^T v = 1$.

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{M}] \leavevmode{[}matrix of vectors with rank n-1{]}
sympy.Matrix

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : orthogonal complement for columns of M

\item {} 
type : numpy.array (1d)

\end{itemize}

\end{fulllineitems}



\subsection{\textbf{trajectories}}
\label{pycontroltools:trajectories}

\subsubsection{\textbf{trajectories}}
\label{pycontroltools:id6}
The module \textbf{trajectories} contains functions concerning the construction
of system trajectories.
\phantomsection\label{pycontroltools:module-trajectories.trajectories}\index{trajectories.trajectories (module)}\phantomsection\label{pycontroltools:module-trajectories}\index{trajectories (module)}\index{integrate\_pw() (in module trajectories.trajectories)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:trajectories.trajectories.integrate_pw}\pysiglinewithargsret{\code{trajectories.trajectories.}\bfcode{integrate\_pw}}{\emph{fnc}, \emph{var}, \emph{transpoints}}{}
due to a bug in sympy we must correct the offset in the integral
to make the result continious

\end{fulllineitems}

\index{make\_pw() (in module trajectories.trajectories)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:trajectories.trajectories.make_pw}\pysiglinewithargsret{\code{trajectories.trajectories.}\bfcode{make\_pw}}{\emph{var}, \emph{transpoints}, \emph{fncs}}{}
\end{fulllineitems}



\subsection{\textbf{auxfuncs/math}}
\label{pycontroltools:auxfuncs-math}
The auxfuncs package \textbf{math} contains mathematical auxiliary functions for
\textbf{pycontroltools} categorized in the modules concerning:
\begin{itemize}
\item {} 
differential operators

\item {} 
LaPlace

\item {} 
matrices

\item {} 
miscellaneous

\item {} 
numerical tools

\item {} 
polynomial helpfunctions

\item {} 
Taylor

\end{itemize}


\subsubsection{\textbf{diffoperators}}
\label{pycontroltools:diffoperators}
The module \textbf{diffoperators} contains functions concerning differential
Operators.
\phantomsection\label{pycontroltools:module-auxfuncs.math.diffoperators}\index{auxfuncs.math.diffoperators (module)}\phantomsection\label{pycontroltools:module-diffoperators}\index{diffoperators (module)}\index{div() (in module auxfuncs.math.diffoperators)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.diffoperators.div}\pysiglinewithargsret{\code{auxfuncs.math.diffoperators.}\bfcode{div}}{\emph{vf}, \emph{x}}{}
divergence of a vector field

\end{fulllineitems}

\index{gradient() (in module auxfuncs.math.diffoperators)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.diffoperators.gradient}\pysiglinewithargsret{\code{auxfuncs.math.diffoperators.}\bfcode{gradient}}{\emph{scalar\_field}, \emph{xx}}{}
\# returns a row vector (coverctorfiel)!

\end{fulllineitems}

\index{hoderiv() (in module auxfuncs.math.diffoperators)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.diffoperators.hoderiv}\pysiglinewithargsret{\code{auxfuncs.math.diffoperators.}\bfcode{hoderiv}}{\emph{f}, \emph{x}, \emph{N=2}}{}
computes a H igher O rder derivative of the vectorfield f

Result is a tensor of type (N,0)

or a  n x L x ... x L (N times) hyper Matrix

(represented a (N+1)-dimensional numpy array

\end{fulllineitems}



\subsubsection{\textbf{laplace}}
\label{pycontroltools:laplace}
The module \textbf{laplace} contains functions concerning LaPlace.
\phantomsection\label{pycontroltools:module-auxfuncs.math.laplace}\index{auxfuncs.math.laplace (module)}\phantomsection\label{pycontroltools:module-laplace}\index{laplace (module)}\index{do\_laplace\_deriv() (in module auxfuncs.math.laplace)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.laplace.do_laplace_deriv}\pysiglinewithargsret{\code{auxfuncs.math.laplace.}\bfcode{do\_laplace\_deriv}}{\emph{laplace\_expr}, \emph{s}, \emph{t}}{}
Example:
laplace\_expr = s*(t**3+7*t**2-2*t+4)
returns: 3*t**2  +14*t - 2

\end{fulllineitems}



\subsubsection{\textbf{matrix}}
\label{pycontroltools:matrix}
The module \textbf{matrix} contains functions concerning operations on matrices.
\phantomsection\label{pycontroltools:module-auxfuncs.math.matrix}\index{auxfuncs.math.matrix (module)}\phantomsection\label{pycontroltools:module-matrix}\index{matrix (module)}\index{all\_k\_minors() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.all_k_minors}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{all\_k\_minors}}{\emph{M}, \emph{k}, \emph{**kwargs}}{}
returns all minors of order k of M

Note that if k == M.shape{[}0{]}

this computes all ``column-minors''

\end{fulllineitems}

\index{as\_mutable\_matrix() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.as_mutable_matrix}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{as\_mutable\_matrix}}{\emph{matrix}}{}
sympy sometimes converts matrices to immutable objects
this can be reverted by a call to    .as\_mutable()
this function provides access to that call as a function
(just for cleaner syntax)

\end{fulllineitems}

\index{cancel\_rows\_cols() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.cancel_rows_cols}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{cancel\_rows\_cols}}{\emph{M}, \emph{rows}, \emph{cols}}{}
cancel rows and cols form a matrix

rows ... rows to be canceled
cols ... cols to be canceled

\end{fulllineitems}

\index{col\_degree() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.col_degree}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{col\_degree}}{\emph{col}, \emph{symb}}{}
\end{fulllineitems}

\index{col\_minor() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.col_minor}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{col\_minor}}{\emph{A}, \emph{*cols}, \emph{**kwargs}}{}
returns the minor (determinant) of the columns in cols

\end{fulllineitems}

\index{col\_select() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.col_select}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{col\_select}}{\emph{A}, \emph{*cols}}{}
selects some columns from a matrix

\end{fulllineitems}

\index{col\_stack() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.col_stack}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{col\_stack}}{\emph{*args}}{}
takes some col vectors and aggregetes them to a matrix

\end{fulllineitems}

\index{concat\_cols() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.concat_cols}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{concat\_cols}}{\emph{*args}}{}
takes some col vectors and aggregetes them to a matrix

\end{fulllineitems}

\index{concat\_rows() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.concat_rows}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{concat\_rows}}{\emph{*args}}{}
takes some row (hyper-)vectors and aggregetes them to a matrix

\end{fulllineitems}

\index{elementwise\_mul() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.elementwise_mul}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{elementwise\_mul}}{\emph{M1}, \emph{M2}}{}
performs elment wise multiplication of matrices

\end{fulllineitems}

\index{ensure\_mutable() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.ensure_mutable}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{ensure\_mutable}}{\emph{arg}}{}
ensures that we handle a mutable matrix (iff arg is a matrix)

\end{fulllineitems}

\index{expand() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.expand}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{expand}}{\emph{arg}}{}
sp.expand currently has no matrix support

\end{fulllineitems}

\index{general\_minor() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.general_minor}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{general\_minor}}{\emph{A}, \emph{rows}, \emph{cols}, \emph{**kwargs}}{}
selects some rows and some cols of A and returns the det of the resulting
Matrix

\end{fulllineitems}

\index{getOccupation() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.getOccupation}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{getOccupation}}{\emph{M}}{}
maps (m\_ij != 0) to every element

\end{fulllineitems}

\index{get\_col\_reduced\_right() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.get_col_reduced_right}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{get\_col\_reduced\_right}}{\emph{A}, \emph{symb}, \emph{T=None}, \emph{return\_internals=False}}{}
Takes a polynomial matrix A(s) and returns a unimod Transformation T(s)
such that   A(s)*T(s) (i.e. right multiplication) is col\_reduced.

Approach is taken from appendix of the PHD-Thesis of S. O. Lindert (2009)
\begin{quote}\begin{description}
\item[{Args}] \leavevmode
A:  Matrix
s:  symbol
T:  unimod-Matrix from preceeding steps

\end{description}\end{quote}

-\textgreater{} recursive approach
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Ar: reduced Matrix
T:  unimodular transformation Matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_rows() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.get_rows}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{get\_rows}}{\emph{A}}{}
returns a list of n x 1 vectors

\end{fulllineitems}

\index{is\_col\_reduced() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.is_col_reduced}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{is\_col\_reduced}}{\emph{A}, \emph{symb}, \emph{return\_internals=False}}{}
tests whether polynomial Matrix A is column-reduced
\begin{description}
\item[{optionally returns internal variables:}] \leavevmode
the list of col-wise max degrees
the matrix with the col.-wise-highest coeffs (Gamma)

\end{description}

Note: concept of column-reduced matrix is important e.g. for
solving a Polynomial System w.r.t. highest order ``derivative''

Note: every matrix can be made col-reduced by unimodular transformation

\end{fulllineitems}

\index{is\_row\_reduced() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.is_row_reduced}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{is\_row\_reduced}}{\emph{A}, \emph{symb}, \emph{*args}, \emph{**kwargs}}{}
transposed Version of is\_col\_reduced(...)

\end{fulllineitems}

\index{matrix\_atoms() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_atoms}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_atoms}}{\emph{M}, \emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{matrix\_count\_ops() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_count_ops}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_count\_ops}}{\emph{M}, \emph{visual=False}}{}
\end{fulllineitems}

\index{matrix\_degrees() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_degrees}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_degrees}}{\emph{A}, \emph{symb}}{}
\end{fulllineitems}

\index{matrix\_random\_equaltest() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_random_equaltest}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_random\_equaltest}}{\emph{M1}, \emph{M2}, \emph{info=False}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{matrix\_series() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_series}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_series}}{\emph{m}, \emph{xx}, \emph{order}, \emph{poly=False}}{}
\end{fulllineitems}

\index{matrix\_subs\_random\_numbers() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_subs_random_numbers}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_subs\_random\_numbers}}{\emph{M}}{}
substitute every symbol in M with a random number

this might be usefull to determine the generic rank of a matrix

\end{fulllineitems}

\index{matrix\_with\_rationals() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.matrix_with_rationals}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{matrix\_with\_rationals}}{\emph{A}}{}
\end{fulllineitems}

\index{mdiff() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.mdiff}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{mdiff}}{\emph{M}, \emph{var}}{}
returns the elementwise derivative of a matrix M w.r.t. var

\end{fulllineitems}

\index{ratsimp() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.ratsimp}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{ratsimp}}{\emph{arg}}{}
sp.ratsimp currently has no matrix support

\end{fulllineitems}

\index{row\_col\_select() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.row_col_select}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{row\_col\_select}}{\emph{A}, \emph{rows}, \emph{cols}}{}
selects some rows and some cols of A and returns the resulting Matrix

\end{fulllineitems}

\index{row\_stack() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.row_stack}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{row\_stack}}{\emph{*args}}{}
takes some row (hyper-)vectors and aggregetes them to a matrix

\end{fulllineitems}

\index{simplify() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.simplify}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{simplify}}{\emph{arg}}{}
sp.simplify currently has no matrix support

\end{fulllineitems}

\index{symbMatrix() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.symbMatrix}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{symbMatrix}}{\emph{n}, \emph{m}, \emph{s='a'}, \emph{symmetric=0}}{}
\end{fulllineitems}

\index{symm\_matrix\_to\_vect() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.symm_matrix_to_vect}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{symm\_matrix\_to\_vect}}{\emph{M}}{}
converts
a b
b c
\begin{quote}

to      {[}a, b, c{]}
\end{quote}

\end{fulllineitems}

\index{symmetryDict() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.symmetryDict}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{symmetryDict}}{\emph{M}}{}
erstellt ein dict, was aus einer beliebigen Matrix M
mittels M.subs(..) eine symmetrische Matrix macht

\end{fulllineitems}

\index{trigsimp() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.trigsimp}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{trigsimp}}{\emph{arg}, \emph{**kwargs}}{}
sp.trigsimp currently has no matrix support

\end{fulllineitems}

\index{unimod\_completion() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.unimod_completion}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{unimod\_completion}}{\emph{col}, \emph{symb}}{}
takes a column and completes it such that the result is unimodular

\end{fulllineitems}

\index{vect\_to\_symm\_matrix() (in module auxfuncs.math.matrix)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.matrix.vect_to_symm_matrix}\pysiglinewithargsret{\code{auxfuncs.math.matrix.}\bfcode{vect\_to\_symm\_matrix}}{\emph{v}}{}
converts
{[}a, b, c{]}
\begin{description}
\item[{to    a b}] \leavevmode
b c

\end{description}

\end{fulllineitems}



\subsubsection{\textbf{miscmath}}
\label{pycontroltools:miscmath}
The module \textbf{miscmath} contains miscellaneous mathematical functions for
\textbf{pycontroltools}.
\phantomsection\label{pycontroltools:module-auxfuncs.math.miscmath}\index{auxfuncs.math.miscmath (module)}\phantomsection\label{pycontroltools:module-miscmath}\index{miscmath (module)}\index{equation (class in auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.equation}\pysiglinewithargsret{\strong{class }\code{auxfuncs.math.miscmath.}\bfcode{equation}}{\emph{lhs}, \emph{rhs=0}}{}
\#chris:  Klasse equation erstellt Gleichungs-Objekte mittles sympify
mit Attributen für Lefthandside (lhs) und Righthandside (rhs)
der Gleichung
\paragraph{Methods}

\end{fulllineitems}

\index{extract\_independent\_eqns() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.extract_independent_eqns}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{extract\_independent\_eqns}}{\emph{M}}{}
handles only homogeneous eqns

M Matrix

returns two lists: indices\_of\_rows, indices\_of\_cols

\end{fulllineitems}

\index{fractionfromfloat() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.fractionfromfloat}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{fractionfromfloat}}{\emph{x\_}, \emph{maxden=1000}}{}
fraction from float
args:
\begin{quote}

x
maxdenominator (default = 1000)
\end{quote}

\end{fulllineitems}

\index{get\_coeff\_row() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.get_coeff_row}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{get\_coeff\_row}}{\emph{eq}, \emph{vars}}{}
takes one equation object and returns the corresponding row of
the system matrix

\end{fulllineitems}

\index{jac() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.jac}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{jac}}{\emph{expr}, \emph{*args}}{}
Calculates the Jacobian matrix (derivative of a vectorial function)
using the \code{jacobian()} function from the module
\code{sympy.matrices.matrices.MatrixBase}.

\textbf{Advantage:} direct derivation of functions

Jacobian matrix:
\begin{quote}
\begin{gather}
\begin{split}J_f(a) :=  \left(\begin{matrix} 
            \frac{\partial f_1}{\partial x_1}(a) &
            \frac{\partial f_1}{\partial x_2}(a) &
            \ldots &
            \frac{\partial f_1}{\partial x_n}(a)\\
            \vdots & \vdots & \ddots & \vdots \\
            \frac{\partial f_m}{\partial x_1}(a) &
            \frac{\partial f_m}{\partial x_2}(a) & \ldots &
            \frac{\partial f_m}{\partial x_n}(a)
            \end{matrix}\right)\end{split}\notag
\end{gather}\end{quote}

\textbf{Parameters}
\begin{itemize}
\item {} \begin{description}
\item[{expr}] \leavevmode{[}expression to derive{]}
function / row matrix/ column matrix

\end{description}

\item {} \begin{description}
\item[{args}] \leavevmode{[}coordinates{]}
separate or as list-like object

\end{description}

\end{itemize}

\textbf{Return}
\begin{itemize}
\item {} 
returns : Jacobi matrix

\item {} 
type : sympy.Matrix

\end{itemize}

\textbf{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sympy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{sympy}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x1 x2 x3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{jac}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x2}\PYG{o}{+}\PYG{n}{x3}\PYG{p}{,} \PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{x3}\PYG{p}{)}
\PYG{g+go}{Matrix([[2*x1, 2, 1]])}
\end{Verbatim}


\strong{See also:}


\code{sympy.jacobian()}



\end{fulllineitems}

\index{lin\_solve\_all() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.lin_solve_all}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{lin\_solve\_all}}{\emph{eqns}}{}
takes a list of equations and tries to solve wrt. to all
ocurring symbols

\end{fulllineitems}

\index{lin\_solve\_eqns() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.lin_solve_eqns}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{lin\_solve\_eqns}}{\emph{eqns}, \emph{vars}}{}
takes a list of equation objects
creates a system matrix of and calls sp.solve

\end{fulllineitems}

\index{lin\_solve\_eqns\_jac() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.lin_solve_eqns_jac}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{lin\_solve\_eqns\_jac}}{\emph{eqns}, \emph{vars}}{}
takes a list of equation objects
creates a system matrix of and calls sp.solve

\# new version !!
\# should replace lin\_solve\_eqns

\# assumes that eqns is a list of expressions where rhs = 0

\end{fulllineitems}

\index{make\_eqns() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.make_eqns}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{make\_eqns}}{\emph{v1}, \emph{v2=None}}{}
\#chris: mehrere lhs,rhs übergeben und daraus Gleichungen erstellen

\end{fulllineitems}

\index{multi\_series() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.multi_series}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{multi\_series}}{\emph{expr}, \emph{xx}, \emph{order}, \emph{poly=False}}{}
Reihenentwicklung (um 0) eines Ausdrucks in mehreren Variablen

\end{fulllineitems}

\index{numer\_denom() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.numer_denom}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{numer\_denom}}{\emph{expr}}{}
\end{fulllineitems}

\index{rat\_if\_close() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.rat_if_close}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{rat\_if\_close}}{\emph{x}, \emph{tol=1e-10}}{}
\end{fulllineitems}

\index{rationalize\_expression() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.rationalize_expression}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{rationalize\_expression}}{\emph{expr}, \emph{tol=1e-10}}{}
substitutes real numbers occuring in expr which are closer than tol to a
rational with a sufficiently small denominator with these rationals

usefull special case 1.2346294e-15 -\textgreater{} 0

\end{fulllineitems}

\index{real\_roots() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.real_roots}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{real\_roots}}{\emph{expr}}{}
\end{fulllineitems}

\index{roots() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.roots}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{roots}}{\emph{expr}}{}
\end{fulllineitems}

\index{sp\_fff() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.sp_fff}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{sp\_fff}}{\emph{x}, \emph{maxden}}{}
sympy\_fraction from float
\#chris: nimmt anscheinend Objekte vom Typ fractions.Fraction
\begin{quote}

(Fraction(133, 10)) und stellt sie als Bruch dar (133/10)
\end{quote}

\end{fulllineitems}

\index{symbs\_to\_func() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.symbs_to_func}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{symbs\_to\_func}}{\emph{expr}, \emph{symbs}, \emph{arg}}{}
in expr replace x by x(arg)
where x is any element of symbs

\end{fulllineitems}

\index{trigsimp2() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.trigsimp2}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{trigsimp2}}{\emph{expr}}{}
sin**2 + cos**2 = 1 in big expressions

\end{fulllineitems}

\index{uv() (in module auxfuncs.math.miscmath)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.miscmath.uv}\pysiglinewithargsret{\code{auxfuncs.math.miscmath.}\bfcode{uv}}{\emph{n}, \emph{i}}{}
unit vectors (columns)

\end{fulllineitems}



\subsubsection{\textbf{numtools}}
\label{pycontroltools:numtools}
The module \textbf{numtools} contains numerical tools.
\phantomsection\label{pycontroltools:module-auxfuncs.math.numtools}\index{auxfuncs.math.numtools (module)}\phantomsection\label{pycontroltools:module-numtools}\index{numtools (module)}\index{chop() (in module auxfuncs.math.numtools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.numtools.chop}\pysiglinewithargsret{\code{auxfuncs.math.numtools.}\bfcode{chop}}{\emph{expr}, \emph{tol=1e-10}}{}
suppress small numerical values

\end{fulllineitems}

\index{clean\_numbers() (in module auxfuncs.math.numtools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.numtools.clean_numbers}\pysiglinewithargsret{\code{auxfuncs.math.numtools.}\bfcode{clean\_numbers}}{\emph{expr}, \emph{eps=1e-10}}{}
trys to clean all numbers from numeric noise

\end{fulllineitems}

\index{dd() (in module auxfuncs.math.numtools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.numtools.dd}\pysiglinewithargsret{\code{auxfuncs.math.numtools.}\bfcode{dd}}{\emph{a}, \emph{b}, \emph{c}, \emph{...) = np.dot(a}, \emph{np.dot(b}, \emph{np.dot(c}, \emph{...))}}{}
\end{fulllineitems}

\index{np\_trunc\_small\_values() (in module auxfuncs.math.numtools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.numtools.np_trunc_small_values}\pysiglinewithargsret{\code{auxfuncs.math.numtools.}\bfcode{np\_trunc\_small\_values}}{\emph{arr}, \emph{lim=1e-10}}{}
\end{fulllineitems}

\index{random\_equaltest() (in module auxfuncs.math.numtools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.numtools.random_equaltest}\pysiglinewithargsret{\code{auxfuncs.math.numtools.}\bfcode{random\_equaltest}}{\emph{exp1}, \emph{exp2}, \emph{info=False}, \emph{integer=False}, \emph{seed=None}, \emph{tol=1e-14}, \emph{min=-1}, \emph{max=1}}{}
serves to check numerically (with random numbers) whether exp1, epx2 are equal
\# TODO: unit test

\end{fulllineitems}

\index{to\_np() (in module auxfuncs.math.numtools)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.numtools.to_np}\pysiglinewithargsret{\code{auxfuncs.math.numtools.}\bfcode{to\_np}}{\emph{arr}, \emph{dtype=\textless{}type `float'\textgreater{}}}{}
converts a sympy matrix in a nice numpy array

\end{fulllineitems}



\subsubsection{\textbf{polynomial}}
\label{pycontroltools:polynomial}
The module \textbf{polynomial} contains functions concerning the construction
of polynomials.
\phantomsection\label{pycontroltools:module-auxfuncs.math.polynomial}\index{auxfuncs.math.polynomial (module)}\phantomsection\label{pycontroltools:module-polynomial}\index{polynomial (module)}\index{coeffs() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.coeffs}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{coeffs}}{\emph{expr}, \emph{var=None}}{}
if var == None, assumes that there is only one variable in expr

\end{fulllineitems}

\index{condition\_poly() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.condition_poly}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{condition\_poly}}{\emph{var}, \emph{*conditions}}{}
\# this function is intended to be a generalization of trans\_poly

returns a polynomial y(t) that fullfills given conditions

every condition is a tuple of the following form:

(t1, y1,  {\color{red}\bfseries{}*}derivs) \# derivs contains cn derivatives

every derivative (to the highest specified {[}in each condition{]}) must be given

\end{fulllineitems}

\index{element\_deg\_factory() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.element_deg_factory}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{element\_deg\_factory}}{\emph{symb}}{}
returns a function for getting the polynomial degree of an expr. w.r.t.
a certain symbol

\end{fulllineitems}

\index{get\_order\_coeff\_from\_expr() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.get_order_coeff_from_expr}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{get\_order\_coeff\_from\_expr}}{\emph{expr}, \emph{symb}, \emph{order}}{}~\begin{description}
\item[{example:}] \leavevmode
3*s**2 -4*s + 5, s, 3 -\textgreater{} 0
3*s**2 -4*s + 5, s, 2 -\textgreater{} 3
3*s**2 -4*s + 5, s, 1 -\textgreater{} -4
3*s**2 -4*s + 5, s, 9 -\textgreater{} 0

\end{description}

\end{fulllineitems}

\index{poly\_coeffs() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.poly_coeffs}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{poly\_coeffs}}{\emph{expr}, \emph{var=None}}{}
returns all (monovariate)-poly-coeffs (including 0s) as a list
first element is highest coeff.

\end{fulllineitems}

\index{poly\_degree() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.poly_degree}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{poly\_degree}}{\emph{expr}, \emph{var=None}}{}
returns degree of monovariable polynomial

\end{fulllineitems}

\index{poly\_scalar\_field() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.poly_scalar_field}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{poly\_scalar\_field}}{\emph{xx}, \emph{symbgen}, \emph{order}, \emph{poly=False}}{}
returns a multivariate poly with specified oders
and symbolic coeffs
returns also a list of the coefficients

\end{fulllineitems}

\index{trans\_poly() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.trans_poly}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{trans\_poly}}{\emph{var}, \emph{cn}, \emph{left}, \emph{right}}{}
returns a polynomial y(t) that is cn times continous differentiable

left and right are sequences of conditions for the boundaries

left = (t1, y1,  {\color{red}\bfseries{}*}derivs) \# derivs contains cn derivatives

\end{fulllineitems}

\index{zeros\_to\_coeffs() (in module auxfuncs.math.polynomial)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.polynomial.zeros_to_coeffs}\pysiglinewithargsret{\code{auxfuncs.math.polynomial.}\bfcode{zeros\_to\_coeffs}}{\emph{*z\_list}, \emph{**kwargs}}{}
calculates the coeffs corresponding to a poly with provided zeros

\end{fulllineitems}



\subsubsection{\textbf{taylor}}
\label{pycontroltools:taylor}
The module \textbf{taylor} contains functions concerning the construction
of Taylor polynomials.
\phantomsection\label{pycontroltools:module-auxfuncs.math.taylor}\index{auxfuncs.math.taylor (module)}\phantomsection\label{pycontroltools:module-taylor}\index{taylor (module)}\index{multi\_taylor() (in module auxfuncs.math.taylor)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.taylor.multi_taylor}\pysiglinewithargsret{\code{auxfuncs.math.taylor.}\bfcode{multi\_taylor}}{\emph{expr}, \emph{args}, \emph{x0=None}, \emph{order=1}}{}
compute a multivariate taylor polynomial of a scalar function

default: linearization about 0 (all args)

\end{fulllineitems}

\index{multi\_taylor\_matrix() (in module auxfuncs.math.taylor)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.taylor.multi_taylor_matrix}\pysiglinewithargsret{\code{auxfuncs.math.taylor.}\bfcode{multi\_taylor\_matrix}}{\emph{M}, \emph{args}, \emph{x0=None}, \emph{order=1}}{}
applies multi\_taylor to each element

\end{fulllineitems}

\index{series() (in module auxfuncs.math.taylor)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.math.taylor.series}\pysiglinewithargsret{\code{auxfuncs.math.taylor.}\bfcode{series}}{\emph{expr}, \emph{var}, \emph{order}}{}
taylor expansion at zero (without O(.) )

\end{fulllineitems}



\subsection{\textbf{auxfuncs/programming}}
\label{pycontroltools:auxfuncs-programming}
The helpfunctions package \textbf{programming} contains helpfunctions for
\textbf{pycontroltools} concerning programming issues.


\subsubsection{\textbf{miscprog}}
\label{pycontroltools:miscprog}
The module \textbf{miscprog} contains miscellaneous functions concerning
programming in \textbf{pycontroltools}.
\phantomsection\label{pycontroltools:module-auxfuncs.programming.miscprog}\index{auxfuncs.programming.miscprog (module)}\phantomsection\label{pycontroltools:module-miscprog}\index{miscprog (module)}\index{atoms() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.atoms}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{atoms}}{\emph{expr}, \emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{aux\_make\_tup\_if\_necc() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.aux_make_tup_if_necc}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{aux\_make\_tup\_if\_necc}}{\emph{arg}}{}
checks whether arg is iterable.
if not return (arg,)

\end{fulllineitems}

\index{expr\_to\_func() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.expr_to_func}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{expr\_to\_func}}{\emph{args}, \emph{expr}, \emph{modules='numpy'}, \emph{**kwargs}}{}
wrapper for sympy.lambdify to handle constant expressions
(shall return a numpyfied function as well)

this function bypasses the following problem:

f1 = sp.lambdify(t, 5*t, modules = ``numpy'')
f2 = sp.lambdify(t, 0*t, modules = ``numpy'')

f1(np.arange(5)).shape \# -\textgreater{} array
f2(np.arange(5)).shape \# -\textgreater{} int

Some special kwargs:
np\_wrapper == True:
\begin{quote}

the return-value of the resulting function is passed through
to\_np(..) before returning
\end{quote}

\end{fulllineitems}

\index{get\_diffterms() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.get_diffterms}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{get\_diffterms}}{\emph{xx}, \emph{order}}{}
returns a list such as

{[}(x1, x1), (x1, x2), (x1, x3), (x2, x2), (x2, x3), (x3, x3){]}

for xx = (x1, x2, x3) and order = 2

\end{fulllineitems}

\index{get\_expr\_var() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.get_expr_var}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{get\_expr\_var}}{\emph{expr}, \emph{var=None}}{}
auxillary function
if var == None returns the unique symbol which is contained in expr:
if no symbol is found, returns None

\end{fulllineitems}

\index{makeGlobal() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.makeGlobal}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{makeGlobal}}{\emph{varList}}{}
injects the symbolic variables of a collection to the global namespace
usefull for interactive sessions

\end{fulllineitems}

\index{make\_global() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.make_global}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{make\_global}}{\emph{varList}}{}
injects the symbolic variables of a collection to the global namespace
usefull for interactive sessions

\end{fulllineitems}

\index{prev() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.prev}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{prev}}{\emph{expr}, \emph{**kwargs}}{}
sympy preview abbreviation

\end{fulllineitems}

\index{rev\_tuple() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.rev_tuple}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{rev\_tuple}}{\emph{tup}}{}
\end{fulllineitems}

\index{simp\_trig\_dict() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.simp_trig_dict}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{simp\_trig\_dict}}{\emph{sdict}}{}
takes a sorted dict, simplifies each value and adds all up

\end{fulllineitems}

\index{subs\_same\_symbs() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.subs_same_symbs}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{subs\_same\_symbs}}{\emph{x+y, {[}x, y{]}) returns x+y, where the symbols are taken from the list (symbs in exp might be different objects with the same name}}{}
returns x+y, where the symbols are taken from the list
(symbs in exp might be different objects with the same name)

this functions helps if expr comes from a string

\end{fulllineitems}

\index{trig\_term\_poly() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.trig_term_poly}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{trig\_term\_poly}}{\emph{expr}, \emph{s}}{}
s ... the argument of sin, cos

\end{fulllineitems}

\index{tup0() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.tup0}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{tup0}}{\emph{xx}}{}
helper function for substituting.
takes (x1, x2, x3, ...)
returns {[}(x1, 0), (x2, 0), ...{]}

\end{fulllineitems}

\index{zip0() (in module auxfuncs.programming.miscprog)}

\begin{fulllineitems}
\phantomsection\label{pycontroltools:auxfuncs.programming.miscprog.zip0}\pysiglinewithargsret{\code{auxfuncs.programming.miscprog.}\bfcode{zip0}}{\emph{xx}, \emph{arg=0}}{}
handy for subtituting equilibrium points

\end{fulllineitems}



\section{How to build the Sphinx documentation for pycontroltools}
\label{README:how-to-build-the-sphinx-documentation-for-pycontroltools}\label{README::doc}
The documentation for the \textbf{pycontroltools} module is created using Sphinx.
To be able to use the tools Sphinx has to be installed
(\href{http://sphinx-doc.org/latest/install.html}{http://sphinx-doc.org/latest/install.html})
and initialized.


\subsection{Initializing Sphinx}
\label{README:initializing-sphinx}
To initialize the Sphinx folder hierarchy for the project,
you preferably create a new folder for the documentation in the main folder of
your project.
(The script files containing the docstrings have to be in the same directory
as the documentation folder or in the documentation folder itself.)

Now start a command console in that folder and type:

\begin{Verbatim}[commandchars=\\\{\}]
sphinx\PYGZhy{}quickstart
\end{Verbatim}


\subsection{Build HTML- and LaTeX-Files}
\label{README:build-html-and-latex-files}
Copy and replace the files from the \textbf{pycontroltools\_sphinx} folder of the
repositorie into your documentation folder.

To build the HTML-files type:

\begin{Verbatim}[commandchars=\\\{\}]
make html
\end{Verbatim}

The build-files appear in the folder \textbf{\_build/html}.

To build the LaTeX-Files type:

\begin{Verbatim}[commandchars=\\\{\}]
make latex
\end{Verbatim}

The build-files appear in the folder \textbf{\_build/latex}.
If a LaTeX distribution is installed on your system, you can now use
the LaTeX files to build (and edit) the document with your own LaTeX editor.


\chapter{Source materials:}
\label{index:source-materials}

\section{Source materials}
\label{pycontroltools_sources:pycontroltools-sources-label}\label{pycontroltools_sources:source-materials}\label{pycontroltools_sources::doc}

\subsection{lie}
\label{pycontroltools_sources:lie}

\subsection{linearcontrol}
\label{pycontroltools_sources:linearcontrol}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
{\hyperref[pycontroltools_sources:pycontroltools-sources-label]{\emph{Source materials}}}

\item {} 
\emph{search}

\end{itemize}

\begin{thebibliography}{Reinschke14}
\bibitem[Isidori]{Isidori}{\phantomsection\label{pycontroltools_sources:isidori} 
A. Isidori: \emph{Nonlinear Control Systems}. Springer-Verlag,
3rd edition, 1995
}
\bibitem[Reinschke14]{Reinschke14}{\phantomsection\label{pycontroltools_sources:reinschke14} \begin{enumerate}
\setcounter{enumi}{10}
\item {} 
Reinschke: \emph{Optimale Polplatzierung für MIMO-Systeme}

\end{enumerate}
}
\end{thebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
